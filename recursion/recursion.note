Tail Recursion
--------------

An algorithm uses tail recursion if it uses Linear recursion and a recusive statement at the end

Like a factorial function or in array recursion.

We can iterate through the recursive calls rather than calling them recursively

in the factorial example:

fact =1
while i<=n do
    fact ->fact*i
    i->i+1

or in the reversing array example

while i>j do 
    swap a[i] and a[j]
    i->i+1
    j->j-1


Binary Recursion
----------------
When there is similar halves for a problem we can use a binary recuresion as in the example of 
the english ruler.

Binary recursion can also be used to find the sum of all the elements in an array

the argument j is the  size of the array passed and the argument i is the index number
of the starting element
the logic is that we are spiting the array in halves until we get j number of arrays with 1 
element each

binarySum(arr,i,j)
if j==1 do
    return arr[i]
else do
    return binarySum(arr,i,n/2)+binarySum(arr,i+n/2,ceil(n/2))

the running time is proportional to n but the space is proportional to 1+log(n)

The Fiboncci is not a  binary recurtion problem rather it is a linear recurtion problem
Using the fibonccci results in  an n! number of function calls

LinarFibbonaci(k):
    if k<1
        return(k,0)
    else
        i,j == LinarFibbonaci(k-1)
        return(i+j,i)
output will be a pair of fibbonacci numbers



